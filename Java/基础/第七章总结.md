一，多态
	1，方法的多态
		a，方法的重载
		b，方法的重写
	2，变量的多态
		a，向上转型（自动类型转换）
			父类声明的变量，可以用来保存本身的对象，也可以用来保存子类的对象
			注意：
				该变量不可以访问子类扩展的属性和方法
				该变量可以访问重写后的方法
		b，向下转型（强制类型转换）
			子类声明的变量，可以用来保存本的对象，也可以用来保存父类的对象
			注意：　
				先向上转型，然后才能使用向下转型

二，抽象的类和方法（abstract）
	１，如果一个方法的方法体无法确定，可以把该方法定义为抽象方法
	２，抽象方法没有方法体
	３，格式：　［修饰符］　abstract 返回值类型  方法名([参数列表]);
	4,如果一个类中有抽象方法，则该类一定是抽象类
	5,抽象类中可以没有抽象方法
	6，抽象类= 普通类+ 抽象方法
	7，抽象类不可以实例化，但是可以用来声明对象，主要被继承
	8，如果一个普通类来继承抽象类时，则必须重写其所有的抽象方法
	9，如果一个抽象的类来继承抽象父类时，则可以不重写其抽象方法

	方法的参数列表可以是对象

三，接口（多实现）
	更加抽象的抽象类
	只能放置  常量和 抽象方法
	格式： public interface  接口名{ 类体  }

	接口可以多继承接口
		public interface 接口名 extends  接口1，接口2，... {}
	类可以单继承父类，也可以多实现接口
	public class 类名 extends 父类名  implements 接口1，接口2，...  {  }

	单继承（类与类）   多实现（类与接口）

四，内部类
	在一个类中，在重新定义一个类
	1，成员内部类
		public class 外部类名｛
			int a=45;
			public void aa(){
			
			}

			public class 内部类名{
				....
			}
		
		｝
	 内部类中不能使用static修饰
	 内部类中可以访问外部类的所有的属性和方法（包含private）
	 外部类也可以访问内部类中的属性和方法，前提要先创建内部类的对象
	 当内部类的属性和方法与外部类的属性和方法重名时，可以使用 外部类名.this.属性名 来调用外部类的属性或方法
	 内部类在外面创建对象时，必须先创建外部类对象，然后才能在此基础上创建内部类
	    例如：    外部类名  外部类对象名  =  new  外部类名();
		      内部类名  内部类对象名  =  外部类对象名.new  内部类名();
	2,静态内部类
		public class 外部类{
			.....
		
			static class 内部类名{
				......
			}
		
		}
	  静态内部类可以使用static修饰
	  静态内部类只可以访问外部类的静态的属性和方法
	  外部类的创建
	   例如：   内部类名  内部类对象  =  new  外部类名.内部类名();

	 3,局部内部类
		public class 外部类{
			....
			public void aa(){
				class 内部类名{
					....
				}
			
			}
		
		}

	   局部内部类的作用于只可以在其定义的方法中
	   局部内部类不能使用修饰符修饰

	  4,匿名内部类
		1,继承抽象的父类
			a，先定义一个抽象的父类（father）
			b，测试
				public class Test{
					public static void main(String [] args){
						Father fa=new Father(){
							重写father中的抽象方法
						}；
					
					}
				}

		2,实现接口
			a，先定义一个抽象的接口（FaInter）
			b，测试
				public class Test{
					public static void main(String [] args){
						FaInter fa=new FaIter(){
							重写FaInter接口中的抽象方法
						}；
					
					}
				}

		
	




